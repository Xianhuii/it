<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/it/favicon.png" />
    

    <title>
        
          作用域 - HHHHHH~
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/it/css/book.css">

    
<script src="/it/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.0.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/it/">
    <img src="/it/favicon.png">
    <span>HHHHHH~</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <h2 id="Home"><a href="/it/">Home</a></h2>
<h2 id="Java-SE">Java-SE</h2>
<ul>
<li><a href="/it/java-se/download-jdk/">download jdk</a></li>
<li><a href="/it/java-se/hello-world/">hello-world</a></li>
<li>String</li>
<li>Collection</li>
<li>Lambda表达式</li>
<li>Stream</li>
</ul>
<h2 id="Spring-core">Spring-core</h2>
<ul>
<li><a href="/it/spring-core/Scope">作用域</a></li>
</ul>

</div>


<script src="/it/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <blockquote>
<p>本文从原理上讲解Spring IoC容器的作用域机制，建议对着源码阅读。</p>
</blockquote>
<h1 id="0-引入问题">0 引入问题</h1>
<p>当我们谈到Spring作用域的时候，自然而然会想到如下作用域（来自spring-core官方文档）：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton</td>
<td>(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>
</tr>
<tr>
<td>prototype</td>
<td>Scopes a single bean definition to any number of object instances.</td>
</tr>
<tr>
<td>request</td>
<td>Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.</td>
</tr>
<tr>
<td>session</td>
<td>Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.</td>
</tr>
<tr>
<td>application</td>
<td>Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.</td>
</tr>
<tr>
<td>websocket</td>
<td>Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.</td>
</tr>
</tbody>
</table>
<p>从功能上看，这些作用域分别定义了调用<code>org.springframework.beans.factory.BeanFactory#getBean()</code>方法时，容器根据<code>bean definition</code>实例化<code>bean object</code>的规则。</p>
<p>从底层实现上看，这些作用域可以分成两类：</p>
<ol>
<li>内置作用域：<code>singleton</code>和<code>prototype</code>。</li>
<li>自定义作用域：<code>request</code>、<code>session</code>、<code>application</code>、<code>websocket</code>以及我们自定义的作用域。</li>
</ol>
<p>所有Spring IoC容器中都具备<code>singleton</code>和<code>prototype</code>作用域功能，而只有实现Web功能的容器（如<code>org.springframework.web.context.support.GenericWebApplicationContext</code>接口）中才具备<code>request</code>和<code>session</code>等作用域功能。这是因为它们底层的实现机制不同。</p>
<p>spring-core官方文档中说了这么一段话：</p>
<p><img src="image-20211116220207985.png" alt=""></p>
<p>我个人这么理解作用域机制的扩展性：</p>
<ol>
<li>内置的<code>singleton</code>和<code>prototype</code>作用域——不可扩展。</li>
<li>可以复写<code>request</code>和<code>session</code>等预定义作用域的规则——可扩展。</li>
<li>可以自定义作用域——可扩展。</li>
</ol>
<p>以上简要概括了Spring IoC容器作用域的基本概念，希望能够引起大家思考以下几个问题（本文后续部分会一一探讨）：</p>
<ol>
<li>什么是作用域？如何使用作用域？</li>
<li>作用域的底层原理？</li>
<li>内置作用域和自定义作用域的区别？</li>
<li>如何自定义作用域？</li>
</ol>
<h1 id="1-什么是作用域？如何使用作用域？">1 什么是作用域？如何使用作用域？</h1>
<h2 id="1-1-什么是作用域？">1.1 什么是作用域？</h2>
<p>作用域是个很宽泛的概念，本文讨论的特指是Spring IoC容器中<code>Bean</code>对象的作用域，简单可以理解成：<code>bean</code>对象的存活范围。</p>
<p>为了便于深入理解，我们先要大概了解一下Spring IoC容器的工作原理。Spring IoC容器的使用流程大概可以分为以下3个步骤：</p>
<ol>
<li>
<p>配置<code>Bean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建Spring IoC容器，并读取配置信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfiguration.class);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从容器中获取<code>bean</code>，并使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">System.out.println(a);	<span class="comment">// com.xianhuii.spring.beanscopes.demo01.A@16267862</span></span><br><span class="line">a = context.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">System.out.println(a);	<span class="comment">// com.xianhuii.spring.beanscopes.demo01.A@16267862</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong><code>Bean</code>作用域本质上指的是多次调用<code>context.getBean()</code>方法获取到的是否是同一个<code>bean</code>对象。</strong></p>
<p>上面例子中，默认指定作用域为<code>singleton</code>，所以两次调用<code>context.getBean()</code>方法获取到同一个对象。</p>
<p>如果指定作用域为<code>prototype</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，两次调用<code>context.getBean()</code>方法获取到就是两个对象了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">System.out.println(a);	<span class="comment">// com.xianhuii.spring.beanscopes.demo01.A@49070868</span></span><br><span class="line">a = context.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">System.out.println(a);	<span class="comment">// com.xianhuii.spring.beanscopes.demo01.A@6385cb26</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-如何使用作用域？">1.2 如何使用作用域？</h2>
<p>作用域的使用比较简单，只需要在配置<code>Bean</code>时使用指定作用域即可。我们使用作用域的重点其实在于不同作用域下<code>context.getBean()</code>的规则。</p>
<h3 id="1-2-1-singleton">1.2.1 <code>singleton</code></h3>
<p><code>singleton</code>作用域下，多次调用<code>context.getBean()</code>方法获取到同一个对象。</p>
<ul>
<li>配置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfiguration.class);</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">System.out.println(a);	<span class="comment">// com.xianhuii.spring.beanscopes.demo01.A@16267862</span></span><br><span class="line">a = context.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">System.out.println(a);	<span class="comment">// com.xianhuii.spring.beanscopes.demo01.A@16267862</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-prototype">1.2.2 <code>prototype</code></h3>
<p><code>prototype</code>作用域下，每次调用<code>context.getBean()</code>方法获取到新对象。</p>
<ul>
<li>配置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfiguration.class);</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">System.out.println(a);	<span class="comment">// com.xianhuii.spring.beanscopes.demo01.A@49070868</span></span><br><span class="line">a = context.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">System.out.println(a);	<span class="comment">// com.xianhuii.spring.beanscopes.demo01.A@6385cb26</span></span><br></pre></td></tr></table></figure>
<h1 id="2-作用域的底层原理？">2 作用域的底层原理？</h1>
<p><strong><code>Bean</code>作用域本质上指的是多次调用<code>context.getBean()</code>方法获取到的是否是同一个<code>bean</code>对象。</strong></p>
<p>所以，作用域底层执行原理在<code>context.getBean()</code>方法中，其中与作用域有关的执行流程如下：</p>
<ol>
<li>从<code>BeanFactory</code>中获取已加载的<code>BeanDefinition</code>，判断该<code>Bean</code>的作用域。</li>
<li>如果是<code>singleton</code>作用域，则执行单例创建规则。</li>
<li>如果是<code>prototype</code>作用域，则执行原型创建规则。</li>
<li>如果是自定义作用域，则执行自定义创建规则。</li>
</ol>
<p>相关核心源码如下（<code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean()</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取BeanDefinition</span></span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、如果作用域是singleton，执行对应创建规则：创建bean，并放到容器中</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、如果作用域是prototype，执行对应创建规则：创建bean，但不会放到容器中</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3、如果是自定义作用域，执行对应创建规则：自定义规则</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">    <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-singleton作用域">2.1 <code>singleton</code>作用域</h2>
<p><code>singleton</code>作用域<code>bean</code>对象的创建过程分为三个步骤：</p>
<ol>
<li>判断是否为<code>singleton</code>作用域。</li>
<li>根据<code>singleton</code>规则创建<code>bean</code>对象。</li>
<li>对<code>bean</code>对象进行后处理。</li>
</ol>
<h3 id="1、判断">1、判断</h3>
<p><code>mbd.isSingleton()</code>方法（<code>org.springframework.beans.factory.support.AbstractBeanDefinition#isSingleton</code>）的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> SCOPE_SINGLETON.equals(<span class="built_in">this</span>.scope) || SCOPE_DEFAULT.equals(<span class="built_in">this</span>.scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中两个静态变量分别为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;	<span class="comment">// &quot;singleton&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCOPE_DEFAULT</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>所以，我们在声明<code>Bean</code>时，以下情况会声明为<code>singleton</code>作用域：</p>
<ol>
<li>
<p>默认情况（即不显示指定作用域），会默认声明为<code>SCOPE_DEFAULT</code>作用域，而<code>SCOPE_DEFAULT</code>实际上就是<code>singleton</code>作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显示指定为<code>singleton</code>作用域，通过<code>@Scope(&quot;singleton&quot;)</code>等方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显示指定为默认作用域，通过<code>@Scope</code>等方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2、创建单例bean">2、创建单例<code>bean</code></h3>
<p>创建单例<code>bean</code>的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建bean</span></span><br><span class="line">      <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="comment">// 创建失败，删除缓存</span></span><br><span class="line">      destroySingleton(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其核心在于<code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</code>方法，其中定义了大部分创建单例<code>bean</code>的规则（模板方法模式）：</p>
<ol>
<li>为<code>singletonObjects</code>对象（单例对象缓存）加锁：一次只能创建一个单例对象。</li>
<li>从<code>singletonObjects</code>中获取当前<code>beanName</code>的对象。</li>
<li>如果存在，说明已经创建，直接返回。</li>
<li>如果不存在，说明还没有创建，则进行创建对象：
<ol>
<li>预处理。</li>
<li>创建对象。</li>
<li>后处理。</li>
<li>添加到singletonObjects缓存。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// 1、singletonObjects缓存加锁</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 2、从singletonObjects缓存中获取singletonObject</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">      <span class="comment">// 3、如果不存在，则创建新对象</span></span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 3.1、预处理</span></span><br><span class="line">         beforeSingletonCreation(beanName);</span><br><span class="line">         <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3.2、创建对象</span></span><br><span class="line">            singletonObject = singletonFactory.getObject();</span><br><span class="line">            newSingleton = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">               <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3.3、后处理</span></span><br><span class="line">            afterSingletonCreation(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">            <span class="comment">// 3.4、添加到singletonObjects缓存</span></span><br><span class="line">            addSingleton(beanName, singletonObject);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4、如果存在，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> singletonObject;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，预处理和后处理都是单例对象创建过程中的回调，可以通过重写自定义回调规则。默认情况下，预处理和后处理会分别标记/清除单例对象“创建中”的标记。</p>
<p><code>addSingleton(beanName, singletonObject)</code>方法会将该对象添加到<code>singletonObjects</code>单例对象缓存和<code>registeredSingletons</code>已注册单例对象缓存中，并将该对象从<code>singletonFactories</code>单例工厂缓存和<code>earlySingletonObjects</code>早期单例对象缓存中移除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="built_in">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">      <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">      <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">      <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的<code>singletonFactory.getObject()</code>方法是外部传入的，即调用该方法实际上会执行外部传入的匿名对象中定义的方法：</p>
<ol>
<li>调用<code>createBean(beanName, mbd, args)</code>会使用反射机制创建<code>bean</code>对象。</li>
<li>如果创建失败，则调用<code>destroySingleton(beanName)</code>方法删除相关缓存信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">   <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">   <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">   <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">   destroySingleton(beanName);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、后处理">3、后处理</h3>
<p><code>org.springframework.beans.factory.support.AbstractBeanFactory#getObjectForBeanInstance</code>方法会对上述根据<code>BeanDefinition</code>创建处理<code>bean</code>进行后处理，该方法其实就是Spring AOP功能的入口。其内部会进行如下判断：</p>
<ol>
<li>容器内部使用。</li>
<li>是否为普通<code>bean</code>：直接返回。</li>
<li>是否为<code>org.springframework.beans.factory.FactoryBean</code>实现类：Spring AOP核心类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">      Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1、pring容器内部bean，不必太过关注</span></span><br><span class="line">   <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2、普通bean，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3、FactoryBean对象，通过AOP功能获取其真正代理的对象</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">      FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">      <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">      object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-prototype作用域">2.2 <code>prototype</code>作用域</h2>
<p><code>prototype</code>作用域<code>bean</code>对象的创建过程分为三个步骤：</p>
<ol>
<li>判断是否为<code>prototype</code>作用域。</li>
<li>根据<code>prototype</code>规则创建<code>bean</code>对象。</li>
<li>对<code>prototype</code>对象进行后处理。</li>
</ol>
<h3 id="1、判断-v2">1、判断</h3>
<p><code>mbd.isPrototype()</code>方法（<code>org.springframework.beans.factory.support.AbstractBeanDefinition#isPrototype</code>）的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> SCOPE_PROTOTYPE.equals(<span class="built_in">this</span>.scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中静态变量为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;	<span class="comment">// &quot;prototype&quot;</span></span><br></pre></td></tr></table></figure>
<p>所以，我们在声明<code>Bean</code>时，可以通过<code>@Scope(&quot;prototype&quot;)</code>等方式显示指定为<code>prototype</code>作用域：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、创建原型bean">2、创建原型<code>bean</code></h3>
<p>有了以上经验，我们就能很容易理解创建原型<code>bean</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 1、预处理，默认标记为“创建中”状态</span></span><br><span class="line">   beforePrototypeCreation(beanName);</span><br><span class="line">   <span class="comment">// 2、通过反射机制创建对象</span></span><br><span class="line">   prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">// 3、后处理，默认移除“创建中”标记</span></span><br><span class="line">   afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、后处理-v2">3、后处理</h3>
<p>该后处理过程与<code>singleton</code>作用域完全相同。</p>
<h2 id="2-3-自定义作用域">2.3 自定义作用域</h2>
<p>如果<code>BeanDefinition</code>既不是<code>singleton</code>，也不是<code>prototype</code>，那么就会执行自定义作用域的创建规则：</p>
<ol>
<li>获取<code>BeanDefinition</code>的<code>scope</code>属性值。</li>
<li>从<code>BeanFactory</code>的作用域缓存<code>scopes</code>中获取对应的作用域。</li>
<li>调用<code>scope.get()</code>方法，执行自定义创建规则。</li>
<li>后处理：Spring AOP功能入口，与<code>singleton</code>和<code>prototype</code>相同。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、获取BeanDefinition的scope属性值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line"><span class="comment">// 2、从BeanFactory的作用域缓存scopes中获取对应的作用域</span></span><br><span class="line"><span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 3、执行自定义创建规则</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">      beforePrototypeCreation(beanName);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         afterPrototypeCreation(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// 4、后处理</span></span><br><span class="line">   beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上源码中我们可以得出自定义作用域的三个步骤：</p>
<ol>
<li>
<p>创建作用域实现类：实现<code>org.springframework.beans.factory.config.Scope</code>接口，实现其<code>get()</code>方法。</p>
</li>
<li>
<p>将作用域实现类注册到<code>BeanFactory</code>的<code>scopes</code>缓存中：key为作用域名，value为自定义作用域对象（<code>org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope</code>）。</p>
</li>
<li>
<p>配置<code>Bean</code>时，指定对应的作用域名。</p>
</li>
</ol>
<h1 id="3-内置作用域和自定义作用域的区别？">3 内置作用域和自定义作用域的区别？</h1>
<p>通过上述的讲解，想必大家对内置作用域（<code>singleton</code>和<code>prototype</code>）和自定义作用域的区别有了本质上的理解。</p>
<p>内置作用域的作用域名和<code>bean</code>创建规则已经写死到Spring IoC容器中。</p>
<p>自定义作用域通过自定义的作用域名从<code>BeanFactory</code>的<code>scopes</code>缓存中找到自定义作用域实现类，根据其中实现的<code>get()</code>方法创建<code>bean</code>。同时，自定义作用域的<code>bean</code>对象存放于自定义的缓存中。</p>
<h1 id="4-自定义作用域案例：request">4 自定义作用域案例：<code>request</code></h1>
<p>接下来，我们以<code>request</code>作用域为例，展示如何自定义作用域。</p>
<h2 id="4-1-RequestScope实现类">4.1 <code>RequestScope</code>实现类</h2>
<p>该实现类全限定类名为<code>org.springframework.web.context.request.RequestScope</code>。</p>
<p>其中，最核心的的部分在于<code>org.springframework.web.context.request.AbstractRequestAttributesScope#get</code>：</p>
<ol>
<li>获取当前请求的<code>RequestAttributes</code>对象。</li>
<li>从缓存中获取<code>bean</code>。</li>
<li>如果缓存中不存在，则需要重新创建：
<ol>
<li>使用<code>objectFactory</code>匿名对象创建<code>bean</code>。</li>
<li>将<code>bean</code>放到缓存中。</li>
<li>重新从缓存中获取。</li>
</ol>
</li>
<li>如果缓存中存在，直接返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// 1、获取当前请求的RequestAttributes缓存对象。</span></span><br><span class="line">   <span class="type">RequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> RequestContextHolder.currentRequestAttributes();</span><br><span class="line">   <span class="comment">// 2、从缓存中获取bean</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">scopedObject</span> <span class="operator">=</span> attributes.getAttribute(name, getScope());</span><br><span class="line">   <span class="comment">// 3、如果缓存中不存在，则需要重新创建</span></span><br><span class="line">   <span class="keyword">if</span> (scopedObject == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 3.1、使用objectFactory匿名对象创建bean</span></span><br><span class="line">      scopedObject = objectFactory.getObject();</span><br><span class="line">      <span class="comment">// 3.2、将bean存放到缓存中</span></span><br><span class="line">      attributes.setAttribute(name, scopedObject, getScope());</span><br><span class="line">      <span class="comment">// 3.3、重新从缓存中获取</span></span><br><span class="line">      <span class="comment">// Retrieve object again, registering it for implicit session attribute updates.</span></span><br><span class="line">      <span class="comment">// As a bonus, we also allow for potential decoration at the getAttribute level.</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">retrievedObject</span> <span class="operator">=</span> attributes.getAttribute(name, getScope());</span><br><span class="line">      <span class="keyword">if</span> (retrievedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// Only proceed with retrieved object if still present (the expected case).</span></span><br><span class="line">         <span class="comment">// If it disappeared concurrently, we return our locally created instance.</span></span><br><span class="line">         scopedObject = retrievedObject;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4、如果缓存中存在，直接返回</span></span><br><span class="line">   <span class="keyword">return</span> scopedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-注册作用域">4.2 注册作用域</h2>
<p>在实现Web功能的容器（如<code>org.springframework.web.context.support.GenericWebApplicationContext</code>接口）中，会自动将<code>request</code>等自定义作用域注册到<code>BeanFactory</code>的<code>scopes</code>缓存中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ServletContextAwareProcessor</span>(<span class="built_in">this</span>.servletContext));</span><br><span class="line">      beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">   &#125;</span><br><span class="line">   WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="built_in">this</span>.servletContext);</span><br><span class="line">   WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="built_in">this</span>.servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里会调用封装好的<code>WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);</code>方法进行注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerWebApplicationScopes</span><span class="params">(ConfigurableListableBeanFactory beanFactory,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> ServletContext sc)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1、注册request作用域：key为request，value为RequestScope实现类</span></span><br><span class="line">   beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, <span class="keyword">new</span> <span class="title class_">RequestScope</span>());</span><br><span class="line">   <span class="comment">// 2、注册session作用域：key为session，value为SessionScope实现类</span></span><br><span class="line">   beanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, <span class="keyword">new</span> <span class="title class_">SessionScope</span>());</span><br><span class="line">   <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 3、注册application作用域：key为application，value为ServletContextScope实现类</span></span><br><span class="line">      <span class="type">ServletContextScope</span> <span class="variable">appScope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextScope</span>(sc);</span><br><span class="line">      beanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);</span><br><span class="line">      <span class="comment">// Register as ServletContext attribute, for ContextCleanupListener to detect it.</span></span><br><span class="line">      sc.setAttribute(ServletContextScope.class.getName(), appScope);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   beanFactory.registerResolvableDependency(ServletRequest.class, <span class="keyword">new</span> <span class="title class_">RequestObjectFactory</span>());</span><br><span class="line">   beanFactory.registerResolvableDependency(ServletResponse.class, <span class="keyword">new</span> <span class="title class_">ResponseObjectFactory</span>());</span><br><span class="line">   beanFactory.registerResolvableDependency(HttpSession.class, <span class="keyword">new</span> <span class="title class_">SessionObjectFactory</span>());</span><br><span class="line">   beanFactory.registerResolvableDependency(WebRequest.class, <span class="keyword">new</span> <span class="title class_">WebRequestObjectFactory</span>());</span><br><span class="line">   <span class="keyword">if</span> (jsfPresent) &#123;</span><br><span class="line">      FacesDependencyRegistrar.registerFacesDependencies(beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-配置Bean">4.3 配置<code>Bean</code></h2>
<p>在定义<code>Bean</code>时，通过指定作用域为<code>request</code>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;request&quot;)</span></span><br><span class="line"><span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便，Spring还实现了<code>@RequestScope</code>注解，使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@RequestScope</span></span><br><span class="line"><span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@RequestScope</code>本质上和<code>@Scope(&quot;request&quot;)</code>没有任何区别（不过我们在自定义作用域时可以采用类似的方式来炫技）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Scope(WebApplicationContext.SCOPE_REQUEST)</span>	<span class="comment">// 相当于@Scope(&quot;request&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestScope &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> Scope#proxyMode&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Defaults to &#123;<span class="doctag">@link</span> ScopedProxyMode#TARGET_CLASS&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@AliasFor(annotation = Scope.class)</span></span><br><span class="line">   ScopedProxyMode <span class="title function_">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-自定义作用域实战">5 自定义作用域实战</h1>
<p>在文章的最后，我们通过实战来自定义作用域<code>myScope</code>，用来简单模拟<code>singleton</code>作用域：</p>
<ol>
<li>第一次调用<code>context.getBean()</code>方法时创建新<code>bean</code>。</li>
<li>之后每次调用<code>context.getBean()</code>方法都会获取同一个<code>bean</code>。</li>
</ol>
<h2 id="5-1-MyScope实现类">5.1 <code>MyScope</code>实现类</h2>
<p>该实现类核心在于<code>get()</code>方法，其他方法都使用默认实现，因此省略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScope</span> <span class="keyword">implements</span> <span class="title class_">Scope</span> &#123;</span><br><span class="line">    <span class="comment">// bean缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、从缓存中获取bean</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanMap.get(name);</span><br><span class="line">        <span class="comment">// 2、如果缓存中不存在，则新建</span></span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1创建bean实例</span></span><br><span class="line">            bean = objectFactory.getObject();</span><br><span class="line">            <span class="comment">// 2.2、放到缓存中</span></span><br><span class="line">            beanMap.put(name, bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3、如果缓存中存在，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-注册作用域">5.2 注册作用域</h2>
<p>注册作用域的方法定义为<code>org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfiguration</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerScope</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">            <span class="type">ConfigurableBeanFactory</span> <span class="variable">configurableBeanFactory</span> <span class="operator">=</span> (ConfigurableBeanFactory) beanFactory;</span><br><span class="line">            configurableBeanFactory.registerScope(<span class="string">&quot;myScope&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyScope</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-配置Bean">5.3 配置<code>Bean</code></h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;myScope&quot;)</span></span><br><span class="line"><span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-测试">5.4 测试</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> ApplicationRunner <span class="title function_">runner</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplicationRunner</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            MyScope.getBeanMap().forEach((key, value) -&gt; &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;key: &quot;</span> + key + <span class="string">&quot;, value: &quot;</span> + value);</span><br><span class="line">            &#125;);</span><br><span class="line">            a = applicationContext.getBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            MyScope.getBeanMap().forEach((key, value) -&gt; &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;key: &quot;</span> + key + <span class="string">&quot;, value: &quot;</span> + value);</span><br><span class="line">            &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(Application.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.xianhuii.springboot.demo.A@757194dc</span><br><span class="line">key: a, value: com.xianhuii.springboot.demo.A@757194dc</span><br><span class="line">com.xianhuii.springboot.demo.A@757194dc</span><br><span class="line">key: a, value: com.xianhuii.springboot.demo.A@757194dc</span><br></pre></td></tr></table></figure>

</div>


  <div class="book-comments">
    




  </div>



<script src="/it/js/book-post.js"></script>


        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="X"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>Xianhuii</div>
      <div>2022-03-05</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/it/categories/spring-core/">spring-core</a>

      <a class="tag-none-link" href="/it/tags/spring/" rel="tag">#spring</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/it/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/it/js/book.js"></script>
